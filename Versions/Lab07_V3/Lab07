#!/usr/bin/python3

import tkinter as tk
from tkinter import ttk
from tkinter import *
from tkinter import messagebox as tkMessageBox
from PIL import Image, ImageTk
import random
import time
import serial
import serial.tools.list_ports as port_list
import serial.serialutil
#sudo apt-get install python3 python-pygame
import pygame
import threading

count = 0
tot = 0
mean_y_pos = 0
start_time = 0
min_partial_init = 100000
min_partial = min_partial_init
min_mean_init = 100000
min_mean = min_mean_init
serialFlag = 0
flag_off = 1
flag_on = 1
max_rand_time = 2
min_rand_time = 1
Serial_def = 0
Togglec=1;
ImageW = 1366
ImageH = 766
WelcW = 600
WelcH=50
flagMusic=1
stop=0
destroyLoading=0

ImageDir = "Img/"

def connectBoard():
	global connect, portsList

	connect = Toplevel()
	connect.title("Serial connection")

	width_screen, height_screen = connect.winfo_screenwidth(), connect.winfo_screenheight() #read the dimensions of the screen
	width_root, height_root = int(width_screen/3),int(height_screen/3) #calculate the dimensions of the main window
	connect.geometry("%dx%d" % (width_root, height_root)) #setup of the window dimensions
	connect.resizable(width=False, height=False) #block the possibility to resize the dimensions of the window

	# backgroud setup
	image = Image.open(ImageDir+"serial_window_bg.png")
	if image.size != (int(width_root), int(height_root)):
	    image = image.resize((int(width_root), int(height_root)), Image.ANTIALIAS)

	image = ImageTk.PhotoImage(image)
	bg_label = tk.Label(connect, image = image)
	bg_label.place(x=0, y=0, relwidth=1, relheight=1)
	bg_label.image = image
	
	
	ports = list(port_list.comports())
	for p in ports: 
		portsList.append((p)[0])

	connect.update()

	# we wait for usb to be connected
	while len(portsList)==0:
		ports = list(port_list.comports())
		for p in ports: 
			portsList.append((p)[0])
		time.sleep(0.3)
	
	# creation of progress bar in the connect window
	#s = ttk.Style()
	#s.theme_use('classic')
	#s.configure("red.Horizontal.TProgressbar") #foreground ='red', background='yellow'
	#progress=ttk.Progressbar(connect, orient=HORIZONTAL, length=200, mode='determinate')
	#progress.place(relx=.5, rely=.6, anchor=CENTER)
	#for i in range(1,10000):
	#		progress['value']=i/100
	#	connect.update_idletasks()
	#	time.sleep(0.0015)
	#
	connect.destroy()



def music(): 							#-------------------------------------------------------------
	global flagMusic
	if flagMusic:	
		pygame.init()

		pygame.mixer.music.load("InstantCrush.wav")
		pygame.mixer.music.set_volume(0.05)
		pygame.mixer.music.play()
		time.sleep(1)
		for i in range(5,50):
			pygame.mixer.music.set_volume(i/100)
			time.sleep(0.1)
		flagMusic=0
	


def music_play_stop(): 						#-------------------------------------------------------------
	global stop
	if stop == 0:
		pygame.mixer.music.pause()
		music_button.config(image=photo_music_stop)
		stop=1
	else:
		music_button.config(image=photo_music) 
		pygame.mixer.music.unpause() 
		stop=0



def tryagain_func(event): 					#-------------------------------------------------------------
	tryagain_button.itemconfigure(circleself, image=photo_tryagain_pressed) # the button change color
	root_1.update()	
	time.sleep(0.1)
	root_1.destroy()
	global count, tot, mean_y_pos, min_partial, min_mean, flag_off, flag_on, SerialPort
	try:
		SerialPort.write(b'R') # the value 'R' is sent to initially turn off the LED to syncronize it with the GUI setup
	except:
		count = 0
	count = 0
	tot = 0
	mean_y_pos = 0
	min_partial = 100000
	min_mean = 100000
	flag_off = 0
	flag_on = 1	
	first_screen()



def stop_func(): 						#-------------------------------------------------------------
	root.destroy()	
	global root_1,music_button, photo_music, photo_music_stop
	root_1 = tk.Tk()
	root_1.title("The reaction game")
	global min_partial, min_mean, min_partial_init, min_mean_init, photo_tryagain_pressed, tryagain_button

	width_screen, height_screen = root_1.winfo_screenwidth(), root_1.winfo_screenheight() #read the dimensions of the screen
	width_root, height_root = int(width_screen/2),int(height_screen/2) #calculate the dimensions of the main window
	root_1.geometry("%dx%d" % (width_root, height_root)) #setup of the window dimensions
	root_1.resizable(width=False, height=False) #block the possibility to resize the dimensions of the window

	# backgroud setup
	image = Image.open(ImageDir+"finalscreen.png")
	if image.size != (width_root, height_root):
	    image = image.resize((width_root, height_root), Image.ANTIALIAS)

	image = ImageTk.PhotoImage(image)
	bg_label = tk.Label(root_1, image = image)
	bg_label.place(x=0, y=0, relwidth=1, relheight=1)
	bg_label.image = image

	# text widget setup
	min_partial_text = Text(root_1)

	if min_partial != min_partial_init:
		min_partial_text.place(relx=.32, rely=.3)
		min_partial_text.insert(END, " The best partial time: "+str(min_partial))
		min_partial_text.config(state="disabled", font="times {0} italic".format(int(width_screen*15/ImageW)), fg="#efe26e", width=25, height=1, 
			relief=FLAT, bd=0, bg="#007972", highlightbackground="#64f4d2", highlightcolor="#007c74")
	else:
		min_partial_text.place(relx=.33, rely=.3)
		min_partial_text.insert(END, "  The best partial time: None")
		min_partial_text.config(state="disabled", font="times {0} italic".format(int(width_screen*15/ImageW)), fg="#efe26e", width=24, height=1, 
			relief=FLAT, bd=0, bg="#007972", highlightbackground="#64f4d2", highlightcolor="#007c74")

	min_mean_text = Text(root_1)

	if min_mean != min_mean_init:
		min_mean_text.place(relx=.32, rely=.4)
		min_mean_text.insert(END, 3*" "+"The best mean time: "+str("{0:.4f}".format(min_mean)))
		min_mean_text.config(state="disabled", font="times {0} italic".format(int(width_screen*15/ImageW)), fg="#efe26e", width=25, height=1, 
			relief=FLAT, bd=0, bg="#007972", highlightbackground="#64f4d2", highlightcolor="#007c74")
	else:
		min_mean_text.place(relx=.33, rely=.4)
		min_mean_text.insert(END, 3*" "+"The best mean time: None")
		min_mean_text.config(state="disabled", font="times {0} italic".format(int(width_screen*15/ImageW)), fg="#efe26e", width=24, height=1, 
			relief=FLAT, bd=0, bg="#007972", highlightbackground="#64f4d2", highlightcolor="#007c74")
	
	#Buttons
	### Try again button
	tryagain_DimX = int(width_screen*100/ImageW)
	tryagain_DimY = int(height_screen*100/ImageH)
	image_tryagain = Image.open(ImageDir+"tryagain.png")
	image_tryagain = image_tryagain.resize((tryagain_DimX,tryagain_DimY), Image.ANTIALIAS)
	photo_tryagain = ImageTk.PhotoImage(image_tryagain)
	
	image_tryagain_pressed = Image.open(ImageDir+"tryagain_pressed.png")
	image_tryagain_pressed = image_tryagain_pressed.resize((tryagain_DimX,tryagain_DimY), Image.ANTIALIAS)
	photo_tryagain_pressed = ImageTk.PhotoImage(image_tryagain_pressed)

	tryagain_button = Canvas(root_1,highlightthickness=0,bd=0,width=tryagain_DimX, height=tryagain_DimY,relief="raised")
	tryagain_buttonself=tryagain_button.create_image(tryagain_DimX/2,tryagain_DimY/2, image=photo_tryagain, anchor='c')	
	tryagain_button.place(relx=.815, rely=.45,anchor=CENTER)
	tryagain_button.bind("<Button-1>", tryagain_func)
	

	### Exit button
	exit_DimX = int(width_screen*80/ImageW)
	exit_DimY = int(height_screen*40/ImageH)
	image_exit = Image.open(ImageDir+"exit.png")
	image_exit = image_exit.resize((exit_DimX,exit_DimY), Image.ANTIALIAS)
	photo_exit = ImageTk.PhotoImage(image_exit)
	exit_button = Button(root_1, image=photo_exit, command=root_1.destroy) 
	exit_button.config(width=exit_DimX, height=exit_DimY, bg="#64f4d2", bd=0, relief="raised", 
				highlightbackground="#64f4d2", activebackground="#f78ea2")
	exit_button.place(relx=.515, rely=.65, x=exit_DimX/2, y=-(exit_DimY)/2, anchor=NE)
	
	### Music button
	music_DimX=int(width_screen*25/ImageW)
	music_DimY=int(height_screen*25/ImageH)
	image_music = Image.open(ImageDir+"sound_on.png")
	image_music = image_music.resize((music_DimX,music_DimY), Image.ANTIALIAS)
	photo_music = ImageTk.PhotoImage(image_music)
	image_music_stop = Image.open(ImageDir+"sound_off.png")
	image_music_stop = image_music_stop.resize((music_DimX,music_DimY), Image.ANTIALIAS)
	photo_music_stop = ImageTk.PhotoImage(image_music_stop)
	music_button = Button(root_1, image=photo_music, command=music_play_stop) 
	music_button.config(width=music_DimX, height=music_DimY, bg="#007972", bd=0, relief="raised", 
				highlightbackground="#007972", activebackground="#007972")
	music_button.place(relx=.945, rely=.09, x=music_DimX/2, y=-(music_DimY)/2, anchor=CENTER)	

	root_1.mainloop()



def ToggleOnOff(event): 					#-------------------------------------------------------------
	global Togglec, circle
	circle.unbind("<Button-1>")
	if Togglec:
		Togglec=0
		On()
	else:
		Togglec=1
		Off()
		


def Off():							#-------------------------------------------------------------
	global flag_off, flag_on, SerialPort, Serial_def
	if flag_off == 1 and Serial_def == 1:
		flag_off = 0	
		flag_on = 1
		circle.itemconfigure(circleself,image=photo_green_pressed) # the button change color
		root.update()
		#time.sleep(0.01)		
		rand_time=random.randint(min_rand_time, max_rand_time)
		time.sleep(rand_time)
		circle.itemconfigure(circleself,image=photo_red) # the button change color
		root.update()
		SerialPort.write(b'L0')
		time_func()



def On():							#-------------------------------------------------------------
	global flag_off, flag_on, SerialPort, Serial_def
	if flag_on == 1 and Serial_def == 1:
		flag_off = 1
		flag_on = 0
		circle.itemconfigure(circleself,image=photo_red_pressed) # the button change color
		root.update()
		#time.sleep(0.01)
		rand_time=random.randint(min_rand_time, max_rand_time)
		time.sleep(rand_time)
		circle.itemconfigure(circleself,image=photo_green) # the button change color
		root.update()
		SerialPort.write(b'L1')
		time_func()



def time_func(): 						#-------------------------------------------------------------
	# this function wait from time from microcontroller, create time widget and 
	# calculate mean of various time 
	global count, tot, mean, mean_y_pos, end_time, min_partial, min_mean, delay_time, circle	

	delay_time=int(SerialPort.read(6)[1:6], 16)/1000 # the delay time is red from the

	# lists of times
	number_lenght=11
	count=count+1
	
	if min_partial>delay_time: # calculate the minimum reactive time of the user
		min_partial=delay_time

	if count==8: # it deletes all the present times
		for i in range(1,8):
			text_user_l = Text(root)
			text_user_l.place(relx=.05, rely=i/11+0.07)
			text_user_l.insert(END, 2*" "+"N"+str(i)+":")	
			text_user_l.config(state="disabled", font="times 15 italic", fg="#efe26e", width=number_lenght, height=1, 
					relief=FLAT, bd=0, bg="#007972", highlightbackground="#64f4d2", highlightcolor="#007c74")
		count=1

	time_n = Text(root)
	time_n.place(relx=.05, rely=count/11+0.07)
	time_n.insert(END, 2*" "+"N"+str(count)+": "+str("{0:.4f}".format(delay_time)))	
	time_n.config(state="disabled", font="times 15 italic", fg="#efe26e", width=number_lenght, height=1, 
			relief=FLAT, bd=0, bg="#007972", highlightbackground="#64f4d2", highlightcolor="#007c74")
	tot=tot+delay_time
	
	#means		
	if count==7:
		mean_y_pos+=1
		mean=0
		mean=tot/count

		if min_mean>mean: # calculate the minimum mean of the reactive time of the user
			min_mean=mean

		mean_n = Text(root)
		mean_n.place(relx=.785, rely=mean_y_pos/11+0.07)
		mean_n.insert(END, 2*" "+"M"+str(mean_y_pos)+": "+str(mean))	
		mean_n.config(state="disabled", font="times 15 italic", fg="#efe26e", width=number_lenght, height=1, 
				relief=FLAT, bd=0, bg="#007972", highlightbackground="#64f4d2", highlightcolor="#007c74")
		tot=0
		if mean_y_pos==7:
			stop_func()

	circle.bind("<Button-1>", ToggleOnOff)	



def main(event=None):						#-------------------------------------------------------------
	global circle,circleself, music_button, connect, portsList
	global photo_green, photo_red,photo_green_pressed,photo_red_pressed, photo_music, photo_music_stop
	global root, SerialPort, port_choose, tkvar,popupMenu
	
	user = user_entry.get()
	root_0.destroy()
	root = tk.Tk()
	root.title("The reaction game")

	width_screen, height_screen = root.winfo_screenwidth(), root.winfo_screenheight() #read the dimensions of the screen
	width_root, height_root = int(width_screen/2),int(height_screen/2) #calculate the dimensions of the main window
	root.geometry("%dx%d" % (width_root, height_root)) #setup of the window dimensions
	root.resizable(width=False, height=False) #block the possibility to resize the dimensions of the window

	# backgroud setup
	image = Image.open(ImageDir+"rootscreen.png")
	if image.size != (width_root, height_root):
	    image = image.resize((width_root, height_root), Image.ANTIALIAS)

	image = ImageTk.PhotoImage(image)
	bg_label = tk.Label(root, image = image)
	bg_label.place(x=0, y=0, relwidth=1, relheight=1)
	bg_label.image = image
	
	# text widget with the username	
	#text_user.place(relx=.5, rely=.14, anchor=CENTER)
	welcomeImg = Image.open(ImageDir+"welcome.png")
	welcomeImg = ImageTk.PhotoImage(welcomeImg)

	welcomeCanvas = Canvas(root,highlightthickness=0,bd=0,width=width_root*WelcW/ImageW, 
				height=height_root*WelcH/ImageH,relief="raised")	
	welcomeCanvas.create_image((width_screen*WelcW/3)/ImageW,(height_screen*WelcH/3)/ImageH, image=welcomeImg, anchor='c')
	if user=="":	
		welcomeCanvas.create_text(width_root*WelcW/(2*ImageW),height_root*WelcH/(2.5*ImageH), 
				text="Welcome "+user+"!",font="MathJax_Math 15 bold",fill="#f0c448")
	else:
		welcomeCanvas.create_text(width_root*WelcW/(2*ImageW),height_root*WelcH/(2.5*ImageH), 
				text="Welcome, "+user+"!",font="MathJax_Math 15 bold",fill="#f0c448")	
	welcomeCanvas.place(relx=.5, rely=.16, anchor=CENTER)
	

	# BUTTONS
	### Time button
	time_DimX=int(width_screen*140/ImageW)
	time_DimY=round(height_screen*140/ImageH)
	image_red = Image.open(ImageDir+"time_red_bg.png")
	image_red = image_red.resize((time_DimX,time_DimY), Image.ANTIALIAS)
	photo_red = ImageTk.PhotoImage(image_red)

	image_green = Image.open(ImageDir+"time_green_bg.png")
	image_green = image_green.resize((time_DimX,time_DimY), Image.ANTIALIAS)
	photo_green = ImageTk.PhotoImage(image_green)

	image_red_pressed = Image.open(ImageDir+"time_red_bg_pressed.png")
	image_red_pressed = image_red_pressed.resize((time_DimX,time_DimY), Image.ANTIALIAS)
	photo_red_pressed = ImageTk.PhotoImage(image_red_pressed)

	image_green_pressed = Image.open(ImageDir+"time_green_bg_pressed.png")
	image_green_pressed = image_green_pressed.resize((time_DimX,time_DimY), Image.ANTIALIAS)
	photo_green_pressed = ImageTk.PhotoImage(image_green_pressed)

	circle = Canvas(root,highlightthickness=0,bd=0,width=time_DimX, height=time_DimY,relief="raised")
	circleself=circle.create_image(time_DimX/2,time_DimY/2.01, image=photo_red, anchor='c')
	ToggleOnOff.c=0
	circle.bind("<Button-1>", ToggleOnOff)	
	circle.place(relx=.5, rely=.4,anchor=CENTER)

	### Stop button
	stop_DimX=int(width_screen*80/ImageW)
	stop_DimY=int(height_screen*40/ImageH)
	image_stop = Image.open(ImageDir+"stop.png")
	image_stop = image_stop.resize((stop_DimX,stop_DimY), Image.ANTIALIAS)
	photo_stop = ImageTk.PhotoImage(image_stop)
	stop_button = Button(root, image=photo_stop, command=stop_func) 
	stop_button.config(width=stop_DimX/width_screen, height=stop_DimY/height_screen, bg="#64f4d2", bd=0, relief="raised", 
				highlightbackground="#64f4d2", activebackground="#f78ea2")
	stop_button.place(relx=.5, rely=.67, anchor=CENTER)	
    
    	### Music button
	music_DimX=int(width_screen*25/ImageW)
	music_DimY=int(height_screen*25/ImageH)
	image_music = Image.open(ImageDir+"sound_on.png")
	image_music = image_music.resize((music_DimX,music_DimY), Image.ANTIALIAS)
	photo_music = ImageTk.PhotoImage(image_music)
	image_music_stop = Image.open(ImageDir+"sound_off.png")
	image_music_stop = image_music_stop.resize((music_DimX,music_DimY), Image.ANTIALIAS)
	photo_music_stop = ImageTk.PhotoImage(image_music_stop)
	music_button = Button(root, image=photo_music, command=music_play_stop) 
	music_button.config(width=music_DimX, height=music_DimY, bg="#007972", bd=0, relief="raised", 
				highlightbackground="#007972", activebackground="#007972")
	music_button.place(relx=.945, rely=.09, x=music_DimX/2, y=-(music_DimY)/2, anchor=CENTER)
	
	root.update()
    
	# Ports menù
	portsList = []
	
	ports = list(port_list.comports())
	for p in ports: 
		portsList.append((p)[0])
	# creation of connect window that wait for connection of usb 	
	if len(portsList)==0:
		connectBoard()
	
	
	tkvar = StringVar(root)
	tkvar.set('Set port') # set the default option
	
	SerialPortMenu()
	
	root.update()
	### link function to change dropdown
	tkvar.trace('w', change_dropdown)
	
	root.mainloop()
    
def SerialPortMenu():
	global popupMenu, root
	popupMenu = OptionMenu(root, tkvar, *portsList)
	popupMenu.place(relx=.5, rely=.83, anchor=CENTER)
	popupMenu.config(bd=0, bg="#f74c6e", activebackground="#f10e3c", highlightbackground="#ce0c39", 
			font="times 15", relief=GROOVE, width=12)
	popupMenu['menu'].config(bg="#f74c6e", activebackground="#f10e3c", 
			font="times 15")


def loading(event=None): 					#-------------------------------------------------------------
	global progress	
	s = ttk.Style()
	s.theme_use('classic')
	s.configure("red.Horizontal.TProgressbar") #foreground ='red', background='yellow'
	progress=ttk.Progressbar(root, orient=HORIZONTAL, length=200, mode='indeterminate')
	progress.place(relx=.5, rely=.82, anchor=CENTER)
	progress.start(10)
	


def wait_for_serial_connection():				#-------------------------------------------------------------
	global  port_choose, SerialPort, Serial_def,root,progress,popupMenu,progressFlag
	connected=0

	while not connected:
		try:
			SerialPort = serial.Serial(port_choose, 115200, bytesize=8, parity="N", stopbits=1, timeout=None, xonxoff=0, rtscts=0, dsrdtr=0)		
			SerialPort.write(b'R') # the value 'R' is sent to initially turn off the LED to syncronize it with the GUI setup
			connected=1
		except (OSError, serial.SerialException):			
			connected=0
			time.sleep(0.5)
			flagProgress=1
	
	if progressFlag:
		progress.destroy()

	SerialPortMenu()

	root.update()


def change_dropdown(*args):					#-------------------------------------------------------------
	global port_choose, SerialPort, Serial_def, progress,popupMenu, progressFlag

	port_choose = tkvar.get()
	
	progressFlag=0

	if port_choose!="Set port":
		tg=threading.Thread(target=wait_for_serial_connection)
		tg.start()

		try:
			SerialPort = serial.Serial(port_choose, 115200, bytesize=8, parity="N", 
							stopbits=1, timeout=None, xonxoff=0, rtscts=0, dsrdtr=0)		
			SerialPort.write(b'R') # the value 'R' is sent to initially turn off the LED to syncronize it with the GUI setup
		except (OSError, serial.SerialException):
			loading()	
			progressFlag=1
			popupMenu.destroy()	
	#SerialPort.write(b'R') # the value 'R' is sent to initially turn off the LED to syncronize it with the GUI setup
	Serial_def = 1




def first_screen():						#-------------------------------------------------------------
	global user_entry,music_button, photo_music, photo_music_stop
	global root_0
	global SerialPort, portsList

	t=threading.Thread(target=music)
	t.start()

	root_0 = tk.Tk()
	root_0.title("The reaction game")

	width_screen, height_screen = root_0.winfo_screenwidth(), root_0.winfo_screenheight() #read the dimensions of the screen
	width_root, height_root = int(width_screen/2),int(height_screen/2) #calculate the dimensions of the main window
	root_0.geometry("%dx%d" % (width_root, height_root)) #setup of the window dimensions
	root_0.resizable(width=False, height=False) #block the possibility to resize the dimensions of the window

	# backgroud setup
	image = Image.open(ImageDir+"firstscreen.png")
	if image.size != (width_root, height_root):
	    image = image.resize((width_root, height_root), Image.ANTIALIAS)

	image = ImageTk.PhotoImage(image)
	bg_label = tk.Label(root_0, image = image)
	bg_label.place(x=0, y=0, relwidth=1, relheight=1)
	bg_label.image = image
	
	# serial port
	portsList = []
	
	ports = list(port_list.comports())
	for p in ports: 
		portsList.append((p)[0])

	# entry
	user_entry = Entry(root_0)
	user_entry.config(justify="center", font="times {0} italic".format(int(width_screen*18/ImageW)))
	user_entry.place(relx=.5, rely=.475, anchor=CENTER)
	user_entry.bind("<Return>", main)	

	# begin_button
	begin_DimX=int(width_screen*90/ImageW)
	begin_DimY=int(height_screen*45/ImageH)
	image_begin = Image.open(ImageDir+"begin.png")
	image_begin = image_begin.resize((begin_DimX, begin_DimY), Image.ANTIALIAS)
	photo_begin = ImageTk.PhotoImage(image_begin)
	begin_button = Button(root_0, image=photo_begin, command=main)
	begin_button.config(width=begin_DimX, height=begin_DimY, bg="#64f4d2", bd=0, relief="raised", 
				highlightbackground="#64f4d2", activebackground="#f78ea2")
	begin_button.place(relx=.51, rely=.65, anchor=CENTER)
	
	### Music button
	music_DimX=25
	music_DimY=25
	image_music = Image.open(ImageDir+"sound_on.png")
	image_music = image_music.resize((music_DimX,music_DimY), Image.ANTIALIAS)
	photo_music = ImageTk.PhotoImage(image_music)
	image_music_stop = Image.open(ImageDir+"sound_off.png")
	image_music_stop = image_music_stop.resize((music_DimX,music_DimY), Image.ANTIALIAS)
	photo_music_stop = ImageTk.PhotoImage(image_music_stop)
	music_button = Button(root_0, image=photo_music, command=music_play_stop) 
	music_button.config(width=music_DimX, height=music_DimY, bg="#007972", bd=0, relief="raised", 
				highlightbackground="#007972", activebackground="#007972")
	music_button.place(relx=.945, rely=.09, x=music_DimX/2, y=-(music_DimY)/2, anchor=CENTER)
	root_0.mainloop()


first_screen()


