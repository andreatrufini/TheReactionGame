#!/usr/bin/python3.6


import sys 


###function to read command from command line and save it in variables
def ReadFromCommandLine(L, state):
	if len(sys.argv) != 3: 							#if controls that the number of parameters is correct
		print("The parameters passed must be two!")
	else:
		first=L 
		second=state
	return first, second							#It returns the passed symbols


###Save command in a vector
Command=ReadFromCommandLine(sys.argv[1], sys.argv[2])

#print("{0}" "{1}".format(a[0], a[1]))





###function to control the first parameter is L
def MatchL(letter):
	if letter != "L": 							#if control that the first symbol of command is correct
		print("The first command's symbol must be L!")
		firstcorrectness=0
	else:
		firstcorrectness=1  						#set flag in case of correctness

	#print("firstcorrectness:{0}".format(firstcorrectness))
	return firstcorrectness							#It returns the correctness




###function to control the second symbol is 0 or 1 and save the value in case of correctness.
def Matchstatus(number):
	if (number=="0"): 
		led="0"
		secondcorrectness=1;
	else:
		if (number=="1"): 
			led="1"
			secondcorrectness=1;
		else:
			print("The second command's symbol must be 0 or 1!")
			secondcorrectness=0;
			led="U"
	#print("secondcorrectness:{0}".format(secondcorrectness))
	return secondcorrectness, led   					#It returns the correctness and the status (on=1 or off=0) of Le



###function to control the complete validation of digit command (combines MatchL() and Matchstatus)
def CommandValidation(Comm):
	cond1=MatchL(Comm[0])
	info=Matchstatus(Comm[1])
	cond2=info[0]
	if cond1==1 and cond2==1: 						#if control that the first symbol of command is   correct
			validation=1
			
	else:
		validation=0
	print("validation:{0}".format(validation))
	return validation

CommandValidation(Command)



###function to generate a delay 
def DelayGenerator():
	import random
	from time import sleep
	delay=random.randrange(100, 200, 1) 					#adapt for resolution of tenths of seconds
	sleep(delay/10) 							#argumen must be in second
	#print("delay:{0}".format(delay))

#DelayGenerator()



###function to control which serial ports can be used
def availableSerialPort():
    	import serial
	#import os
        suffixes = "S", "USB", "ACM", "AMA"  					#typical suffixes for serial ports 
	nameList = ["com"] + ["/dev/tty%s" % suffix for suffix in suffixes]  	#different possible name for different operating systems
        portList = []  								#initialization of list to contain name of possible ports
        for name in nameList:
        	for number in range(48):
                	portName = "%s%s" % (name, number)  			#create the possible name port for the serial communication 
	    		#print("{0}".format(portName))
            		try:							#try controls which name of port in portname are ports available on the device		
				#os.chdir("/")						
				#a=os.listdir("./")
                		#print("{0}".format(a))
                		serial.Serial(portName).close()
                		portList.append(portName)			#when there is match between a name in portname and a name of available port on the device, save the port's name in portList
            		except IOError:  					#An error occured trying to read the file
                		pass
    	return tuple(portList)							#return a portList with all name of ports available


availablePort = availableSerialPort()
#print("Available port are: {0}".format(availablePort))



###function to write on serial port
def SendCommand(cmd):
	import serial 												     			  #import module for serial communication
	porta = serial.Serial("/dev/ttyS0", 115200, bytesize=8, parity=serial.PARITY_NONE, stopbits=1, xonxoff=0, rtscts=0, dsrdtr=0)     #initialize and open the door with request parameters
	porta.write(Command)											     			  #write command
SendCommand(Command)



###function to read 5 bytes (Thhhh) from serial port
def Rxtime():
	import serial 
	porta = serial.Serial("/dev/ttyS0", 115200, bytesize=8, parity="N", stopbits=1, timeout=None, xonxoff=0, rtscts=0, dsrdtr=0) 	#set timeout to wait until requested number of bytes are received
	time = porta.read(5)   											     		        #receive 5 bytes
	porta.close()
	return time  												    		        #after receiving simulation's time close the port
Rxtime()



#def availableSerialPort():
#    import serial
#    suffixes = ("S", "USB", "ACM", "AMA")
#    portList = []
#    for suffix in suffixes:
#	 nameList = ["com"] + ["/dev/tty{0}".format(suffix)]
#   	
#    for name in nameList:
#        for number in range(48):
#            portName = ("{0}" "{1}".format(name, number))
#            try:
#                serial.Serial(portName).close()
#                portList.append(portName)
#            except IOError:
#                pass	
#    return tuple(portList)

#availablePort = availableSerialPort()
#print("Available port are: {0}".format(availablePort))



